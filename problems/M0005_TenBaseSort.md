<!--
 * @Date        : 2020-05-02 20:37:47
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-05-11 08:44:56
 * @FilePath    : \algorithm\problems\M0005_TenBaseSort.md
 * @Describe    : 
 -->
## 题目地址

[动画+原理+代码，解读十大经典排序算法](https://mp.weixin.qq.com/s/4oXPVGuGIjbnC0rClVV3Hw)

## 题目描述
排序算法是《数据结构与算法》中最基本的算法之一。

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：<b>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</b>等。
用一张[表格](../resource/img/sort.png)概括：     

| 排序算法     | Name          | 平均时间复杂度 | 最好情况    | 最坏情况    | 空间复杂度 | 排序方式  | 稳定性 |
| ------------ | ------------- | -------------- | ----------- | ----------- | ---------- | --------- | ------ |
| **冒泡排序** | BubbleSort    | O(n²)          | O(n)        | O(n²)       | O(1)       | In-place  | 稳定   |
| **选择排序** | SelectionSort | O(n²)          | O(n²)       | O(n²)       | O(1)       | In-place  | 不稳定 |
| **插入排序** | InsertSort    | O(n²)          | O(n)        | O(n²)       | O(1)       | In-place  | 稳定   |
| **希尔排序** | ShellSort     | O(n log n)     | O(n log² n) | O(n log² n) | O(1)       | In-place  | 不稳定 |
| **归并排序** | MergeSort     | O(n log n)     | O(n log n)  | O(n log n)  | O(n)       | Out-place | 稳定   |
| **快速排序** | QuickSort     | O(n log n)     | O(n log n)  | O(n²)       | O(log n)   | In-place  | 不稳定 |
| **堆排序**   | HeapSort      | O(n log n)     | O(n log n)  | O(n log n)  | O(1)       | In-place  | 不稳定 |
| **计数排序** | CountingSort  | O(n + k)       | O(n + k)    | O(n + k)    | O(k)       | Out-place | 稳定   |
| **桶排序**   | BucketSort    | O(n + k)       | O(n + k)    | O(n²)       | O(n + k)   | Out-place | 稳定   |
| **基数排序** | RadixSort     | O(n × k)       | O(n × k)    | O(n × k)    | O(n + k)   | Out-place | 稳定   |

#### 关于时间复杂度：
平方阶 (O(n²)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。

线性对数阶 (O(nlog²n)) 排序 快速排序、堆排序和归并排序。

O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。

线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。

#### 关于稳定性：
稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

#### 名词解释：
n：数据规模

k：“桶”的个数

In-place：占用常数内存，不占用额外内存

Out-place：占用额外内存

稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

#### 关于内置默认函数sort()
标准库sort();函数并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选copy用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过zhidao深，有出现最坏情况的倾向，还会改用堆排序。--limself

## 思路
### #1 冒泡排序
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。
> ##### 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3. 针对所有的元素重复以上的步骤，除了最后一个。

4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

> ##### 什么时候最快
当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

> ##### 什么时候最慢
当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。

### #2 选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
> ##### 算法步骤
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

### #3 插入排序
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。
> ##### 算法步骤
1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

### #4 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；

- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

> ##### 算法步骤
1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

2. 按增量序列个数 k，对序列进行 k 趟排序；

3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

> #### 其它思路
Shell Sort 存在争议。
- [希尔排序的原理解析](https://baijiahao.baidu.com/s?id=1644158198885715432&wfr=spider&for=pc)
- [面试官：手写一个希尔排序，并对其改进（Java代码实现）](https://baijiahao.baidu.com/s?id=1645338224617537073&wfr=spider&for=pc)

## 代码
>[interface IArraySort](../code/M0005_TenBaseSort/IArraySort.java)  
>[Test.java](../test/Test.java)

#1 
[BubbleSort.java](../code/M0005_TenBaseSort/BubbleSort.java)

#2
[SelectionSort.java](../code/M0005_TenBaseSort/SelectionSort.java)

#3
[InsertSort.java](../code/M0005_TenBaseSort/InsertSort.java)

#4
[ShellSort.java](../code/M0005_TenBaseSort/ShellSort.java)