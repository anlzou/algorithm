<!--
 * @Date        : 2020-05-02 20:37:47
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-05-14 14:28:28
 * @FilePath    : \algorithm\problems\M0005_TenBaseSort.md
 * @Describe    : 
 -->
## 题目地址

[动画+原理+代码，解读十大经典排序算法](https://mp.weixin.qq.com/s/4oXPVGuGIjbnC0rClVV3Hw)

## 题目描述
排序算法是《数据结构与算法》中最基本的算法之一。

排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：<b>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</b>等。
用一张[表格](../resource/img/sort.png)概括：     

| 排序算法                                                 | [代码汇总](#%e4%bb%a3%e7%a0%81%e6%b1%87%e6%80%bb) | 平均时间复杂度 | 最好情况    | 最坏情况    | 空间复杂度 | 排序方式  | 稳定性 |
| -------------------------------------------------------- | ------------------------------------------------- | -------------- | ----------- | ----------- | ---------- | --------- | ------ |
| **[冒泡排序](#1-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f)**  | BubbleSort                                        | O(n²)          | O(n)        | O(n²)       | O(1)       | In-place  | 稳定   |
| **[选择排序](#2-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f)**  | SelectionSort                                     | O(n²)          | O(n²)       | O(n²)       | O(1)       | In-place  | 不稳定 |
| **[插入排序](#3-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f)**  | InsertSort                                        | O(n²)          | O(n)        | O(n²)       | O(1)       | In-place  | 稳定   |
| **[希尔排序](#4-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f)**  | ShellSort                                         | O(n log n)     | O(n log² n) | O(n log² n) | O(1)       | In-place  | 不稳定 |
| **[归并排序](#5-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f)**  | MergeSort                                         | O(n log n)     | O(n log n)  | O(n log n)  | O(n)       | Out-place | 稳定   |
| **[快速排序](#6-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f)**  | QuickSort                                         | O(n log n)     | O(n log n)  | O(n²)       | O(log n)   | In-place  | 不稳定 |
| **[堆排序](#7-%e5%a0%86%e6%8e%92%e5%ba%8f)**             | HeapSort                                          | O(n log n)     | O(n log n)  | O(n log n)  | O(1)       | In-place  | 不稳定 |
| **[计数排序](#8-%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f)**  | CountingSort                                      | O(n + k)       | O(n + k)    | O(n + k)    | O(k)       | Out-place | 稳定   |
| **[桶排序](#9-%e6%a1%b6%e6%8e%92%e5%ba%8f)**             | BucketSort                                        | O(n + k)       | O(n + k)    | O(n²)       | O(n + k)   | Out-place | 稳定   |
| **[基数排序](#10-%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f)** | RadixSort                                         | O(n × k)       | O(n × k)    | O(n × k)    | O(n + k)   | Out-place | 稳定   |

#### 关于时间复杂度：
平方阶 <code>(O(n²))</code> 排序 各类简单排序：直接插入、直接选择和冒泡排序。

线性对数阶 <code>(O(nlog²n))</code> 排序 快速排序、堆排序和归并排序。

<code>O(n1+§))</code> 排序，§ 是介于 0 和 1 之间的常数。 希尔排序。

线性阶 <code>(O(n))</code> 排序 基数排序，此外还有桶、箱排序。

#### 关于稳定性：
稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。

不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。

#### 名词解释：
<code>n</code>：数据规模

<code>k</code>：“桶”的个数

<code>In-place</code>：占用常数内存，不占用额外内存

<code>Out-place</code>：占用额外内存

稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

#### 关于内置默认函数 <code>sort()</code>
标准库sort();函数并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选copy用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过zhidao深，有出现最坏情况的倾向，还会改用堆排序。--limself

## 思路
### #1 冒泡排序
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。
> ##### 算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3. 针对所有的元素重复以上的步骤，除了最后一个。

4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

> ##### 什么时候最快
当输入的数据已经是正序时（都已经是正序了，我还要你冒泡排序有何用啊）。

> ##### 什么时候最慢
当输入的数据是反序时（写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗）。

> #### 代码
- [BubbleSort.java](../code/M0005_TenBaseSort/BubbleSort.java)

### #2 选择排序
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。
> ##### 算法步骤
1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3. 重复第二步，直到所有元素均排序完毕。

> #### 代码
- [SelectionSort.java](../code/M0005_TenBaseSort/SelectionSort.java)

### #3 插入排序
插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。
> ##### 算法步骤
1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

> #### 代码
- [InsertSort.java](../code/M0005_TenBaseSort/InsertSort.java)

### #4 希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。

希尔排序是基于插入排序的以下两点性质而提出改进方法的：

- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；

- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；

希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

> ##### 算法步骤
1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；

2. 按增量序列个数 k，对序列进行 k 趟排序；

3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

> #### 其它思路
Shell Sort 存在争议。
- [希尔排序的原理解析](https://baijiahao.baidu.com/s?id=1644158198885715432&wfr=spider&for=pc)
- [面试官：手写一个希尔排序，并对其改进（Java代码实现）](https://baijiahao.baidu.com/s?id=1645338224617537073&wfr=spider&for=pc)

> #### 代码
- [ShellSort.java](../code/M0005_TenBaseSort/ShellSort.java)

### #5 归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；

- 自下而上的迭代；

在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：

*However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.*

*然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。*

按照老师上课说过，递归算法太深反而效率更低，原因在于内存的开销太大。

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。

> #### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；

2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；

3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；

4. 重复步骤 3 直到某一指针达到序列尾；

5. 将另一序列剩下的所有元素直接复制到合并序列尾。

> #### 代码
- [MergeSort.java](../code/M0005_TenBaseSort/MergeSort.java)

### #6 快速排序
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。

快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：

*快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。*

> #### 算法步骤
快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。
2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。

> #### 其它思路
- [百度百科](https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&fromid=2084344&fr=aladdin)

> #### 代码
- [QuickSort.py](../code/M0005_TenBaseSort/QuickSort.py)

### #7 堆排序
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；

小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆排序的平均时间复杂度为 <code>Ο(nlogn)</code>。

> #### 算法步骤

1. 创建一个堆 H[0……n-1]；

2. 把堆首（最大值）和堆尾互换；

3. 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；

4. 重复步骤 2，直到堆的尺寸为 1。

> #### 其它思路
- [图解排序算法(三)之堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

> #### 代码
- [HeapSort.java](../code/M0005_TenBaseSort/HeapSort.java)

### #8 计数排序
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

> #### 代码
- [CountingSort.java](../code/M0005_TenBaseSort/CountingSort.java)

### #9 桶排序
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：

1. 在额外空间充足的情况下，尽量增大桶的数量

2. 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中

同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

> #### 算法解析
1. 什么时候最快

   - 当输入的数据可以均匀的分配到每一个桶中。

2. 什么时候最慢

   - 当输入的数据被分配到了同一个桶中。

> #### 其它思路
- [算法1：最快最简单的排序——桶排序](https://www.cnblogs.com/bqwzx/p/11029264.html)

第一眼看和计数排序并没有区别，这是简化版。

- [排序算法（九）：桶排序](https://www.jianshu.com/p/204ed43aec0c)

增加每个桶的容量范围，比如宽度为10，然后使用其它算法对每个桶内进行排序，这是升级版。

> #### 代码
[BucketSort.java](../code/M0005_TenBaseSort/BucketSort.java)

### #10 基数排序
基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

> #### 算法步骤

基数排序有两种方法：

- LSD（Least significant digital）
- MSD（Most significant digital）
  - LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。
  - [基数排序简介及LSD、MSD实现](https://www.xuebuyuan.com/1491130.html)

> #### 其它思路

因为基数排序需要找到最大值，所以我们可以在寻找最大值的同时也寻找最小值。

我们可以给所有数减掉最小值，使得数组中肯定不会出现负数，且最小值为0，然后这样我们就可以按照以前基数排序的套路进行排序了。

- [JAVA实现可解决包含负数的基数排序](https://blog.csdn.net/weixin_44233929/article/details/105474017)

> #### 比较 

**基数排序 vs 计数排序 vs 桶排序**

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶；

- 计数排序：每个桶只存储单一键值；

- 桶排序：每个桶存储一定范围的数值；

> #### 代码

[RadixSort.java](../code/M0005_TenBaseSort/RadixSort.java)

## 代码汇总
>[interface IArraySort](../code/M0005_TenBaseSort/IArraySort.java)  
>[Test.java](../test/Test.java)

#1 
[BubbleSort.java](../code/M0005_TenBaseSort/BubbleSort.java)

#2
[SelectionSort.java](../code/M0005_TenBaseSort/SelectionSort.java)

#3
[InsertSort.java](../code/M0005_TenBaseSort/InsertSort.java)

#4
[ShellSort.java](../code/M0005_TenBaseSort/ShellSort.java)

#5
[MergeSort.java](../code/M0005_TenBaseSort/MergeSort.java)

#6
[QuickSort.py](../code/M0005_TenBaseSort/QuickSort.py)

#7 
[HeapSort.java](../code/M0005_TenBaseSort/HeapSort.java)

#8
[CountingSort.java](../code/M0005_TenBaseSort/CountingSort.java)

#9
[BucketSort.java](../code/M0005_TenBaseSort/BucketSort.java)

#10
[RadixSort.java](../code/M0005_TenBaseSort/RadixSort.java)