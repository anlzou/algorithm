<!--
 * @Date        : 2020-05-02 20:37:47
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-05-15 10:30:24
 * @FilePath    : \algorithm\problems\L0005_longest-palindromic-substring.md
 * @Describe    : 
 -->
## 题目地址

[leetcode](https://leetcode-cn.com/problems/longest-palindromic-substring/)

## 题目描述

问题：
```
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```
示例：
```
#1
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

#2
输入: "cbbd"
输出: "bb"
```

## 思路
我们先从简单的算法开始，最简单的方法当然是暴力。由于我们需要求出最长的回文串，一种方法是求出s串所有的子串，然后一一对比它们是否构成回文。这样当然是可行的，但是我们简单分析一下复杂度就会发现，这并不能接受。对于一个长度为n的字符串来说，我们任意选择其中两个位置，就可以找到它的一个子串，那么我们选择两个位置的数量就是$C_n^2 = \frac{n(n-1)}{2}$。对于每一个子串，我们需要遍历一遍才能判断是否回文，所以整体的复杂度是$O(n^3)$。

但是如果你对回文串非常熟悉的话，会发现其实这是可以优化的。因为我们要求的是最长的回文串，如果我们确定了对称中心的位置，它能够构成的最长回文串就是确定的。所以我们只需要遍历所有的回文串中心，和每个中心能找到的最长回文串。这样我们的复杂度就降低了一维，变成了$O(n^2)$。

回文串有两种形式，一种是奇回文，也就是回文中心是一个字符，比如aba。还有一种是偶回文，回文中心是两个字符之间，比如abba。这两种情况我们需要分开讨论。

## 关键点
- 奇回文
- 偶回文

## 代码
[L0005_LongestPalindromicSubstring.py](../code/L0005_LongestPalindromicSubstring.py)

## 复杂度分析

- 时间复杂度：$O(n^2)$
- 空间复杂度：O(n)